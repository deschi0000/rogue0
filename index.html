<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star-Ace: Rogue Squadron Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #hud {
            position: absolute; top: 20px; left: 20px; color: #00ff00;
            pointer-events: none; text-shadow: 2px 2px #000; z-index: 10;
        }
        canvas { cursor: none; }
        .stat { font-size: 1.2rem; margin: 5px 0; font-family: monospace; }

        .stamina-container {
            width: 150px; height: 10px; background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00; margin-top: 5px; position: relative;
        }
        #stamina-fill {
            height: 100%; width: 100%; background: #00ff00;
            transition: background 0.3s;
        }
        .stamina-depleted #stamina-fill { background: #ff0000; }

        #warning {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #ff0000; font-weight: bold; font-size: 2rem; display: none;
            text-shadow: 0 0 10px #ff0000; z-index: 15;
        }
        #reticle {
            position: absolute; width: 40px; height: 40px; border: 1px solid rgba(0, 255, 0, 0.5);
            border-radius: 50%; pointer-events: none; z-index: 20;
        }
        #reticle::before { 
            top: -8px; left: 50%; width: 1px; height: calc(100% + 16px); 
            background: linear-gradient(to bottom, #00ff00 15%, transparent 15%, transparent 85%, #00ff00 85%);
            content: ''; position: absolute;
        }
        #reticle::after { 
            top: 50%; left: -8px; width: calc(100% + 16px); height: 1px; 
            background: linear-gradient(to right, #00ff00 15%, transparent 15%, transparent 85%, #00ff00 85%);
            content: ''; position: absolute;
        }
        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8);
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; color: white; z-index: 100; text-align: center;
        }
        .hidden { display: none !important; }
        button { padding: 15px 30px; font-size: 1.2rem; background: #00ff00; border: none; cursor: pointer; color: black; font-weight: bold; margin-top: 20px; }
    </style>
</head>
<body>

    <div id="hud">
        <div class="stat">SPD: <span id="speed-val">0</span></div>
        <div class="stat">SHD: <span id="shield-val">100</span>%</div>
        <div class="stat">TGT: <span id="enemy-val">0</span></div>
        <div class="stat">BST:</div>
        <div class="stamina-container" id="stamina-parent">
            <div id="stamina-fill"></div>
        </div>
    </div>
    <div id="warning">RETURNING TO BATTLE ZONE</div>
    <div id="reticle"></div>

    <div id="damage-flash" style="position: fixed; inset: 0; background: rgba(229, 255, 0, 0.341); pointer-events: none; opacity: 0; z-index: 50; transition: opacity 0.1s;"></div>

    <div id="pause-screen" class="overlay hidden">
        <h1>PAUSED</h1>
        <button onclick="togglePause()">RESUME</button>
    </div>

    <div id="win-screen" class="overlay hidden">
        <h1>MISSION ACCOMPLISHED</h1>
        <button onclick="location.reload()">REPLAY</button>
    </div>

    <div id="lose-screen" class="overlay hidden">
        <h1>SHIP DESTROYED</h1>
        <button onclick="location.reload()">RETRY</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const BULLET_SPEED = 6;
        const TORPEDO_SPEED = 2.2; // Slightly slower for weight
        const TORPEDO_RANGE = 700;
        const TORPEDO_BLAST_RADIUS = 25; // Radial damage distance
        const ENEMY_FIRE_RATE = 0.01; 
        const BOUNDARY_RADIUS = 1600;
        const ASTEROID_COUNT = 200;
        const SAFE_ZONE_RADIUS = 120; 
        const ENEMY_MAX_SPEED = 0.65;
        const ENEMY_TURN_SPEED = 0.02; 

        const MAX_STAMINA = 100;
        const STAMINA_DRAIN = 20; 
        const STAMINA_RECHARGE = 15; 
        const RECHARGE_DELAY = 2000;

        let isPaused = false, gameActive = true;
        let scene, camera, renderer, player, clock, boundary;
        let speed = 0.8, shields = 100, stamina = MAX_STAMINA, isStaminaDepleted = false, lastBoostTime = 0;
        
        let input = { w: false, s: false, a: false, d: false };
        let mouse = { x: 0, y: 0 };
        let bullets = [], torpedoes = [], enemies = [], obstacles = [], engines = [], wingObjects = [], particles = []; 
        let laserIndex = 0, reticlePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0005);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(50, 50, 50);
            scene.add(sun);

            const boundaryGeo = new THREE.SphereGeometry(BOUNDARY_RADIUS, 32, 32);
            boundary = new THREE.Mesh(boundaryGeo, new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.1 }));
            scene.add(boundary);

            player = new THREE.Group();
            player.userData = { isTurning: false }; 
            const mat = new THREE.MeshPhongMaterial({ color: 0xdddddd });
            
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.2, 5, 5), mat);
            body.rotation.x = Math.PI / 2;
            body.translateY(-1.8)
            player.add(body);

            const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshPhongMaterial({ color: 0x333333, transparent: true, opacity: 0.9 }));
            cockpit.position.set(0, 0.15, 0.1); cockpit.translateZ(-0.5); cockpit.scale.set(1, 1, 1.8);
            player.add(cockpit);

            const createWing = (xSide, ySide, angle) => {
                const wingGroup = new THREE.Group();
                const wing = new THREE.Mesh(new THREE.BoxGeometry(2, 0.05, 1.2), mat);
                wing.position.x = xSide * 1.2;
                wingGroup.add(wing);

                const engineGroup = new THREE.Group();
                const engineBody = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.8, 8), mat);
                engineBody.rotation.x = Math.PI / 2;
                engineGroup.add(engineBody);

                const glow = new THREE.Mesh(new THREE.CircleGeometry(0.15, 8), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                glow.position.z = 0.41;
                engineGroup.add(glow);
                
                const pLight = new THREE.PointLight(0x00ffff, 1, 5);
                pLight.position.z = 0.5;
                engineGroup.add(pLight);
                engines.push({ light: pLight, mesh: glow });

                engineGroup.position.set(xSide * 0.4, 0, 0.5);
                wingGroup.add(engineGroup);

                const cannon = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.5), mat);
                cannon.rotation.x = Math.PI / 2; cannon.position.set(xSide * 2, 0, -0.8);
                wingGroup.add(cannon);

                wingGroup.rotation.z = angle;
                wingGroup.position.y = ySide * 0.1;
                return wingGroup;
            };

            wingObjects = [
                createWing(1, 1, 0.25),   
                createWing(-1, 1, -0.25), 
                createWing(1, -1, -0.25), 
                createWing(-1, -1, 0.25)
            ];
            player.add(...wingObjects);

            scene.add(player);
            camera.position.set(0, 2, 8); 
            player.add(camera);

            const starGeo = new THREE.BufferGeometry();
            const starCoords = [];
            for(let i=0; i<4000; i++) {
                const theta = Math.random() * Math.PI * 2, phi = Math.acos((Math.random() * 2) - 1), dist = 2000 + Math.random() * 1000; 
                starCoords.push(dist * Math.sin(phi) * Math.cos(theta), dist * Math.sin(phi) * Math.sin(theta), dist * Math.cos(phi));
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 1.5})));

            for(let i=0; i<ASTEROID_COUNT; i++) {
                const ast = new THREE.Mesh(new THREE.IcosahedronGeometry(Math.random() * 12 + 3, Math.floor(Math.random() * 2)), new THREE.MeshPhongMaterial({ color: 0x444444 + (Math.random() * 0x222222), flatShading: true }));
                const scale = Math.random() * 2.5 + 0.5; ast.scale.set(scale, scale, scale);
                const theta = Math.random() * Math.PI * 2, phi = Math.acos((Math.random() * 2) - 1), rawDist = Math.random(); 
                const dist = Math.max(SAFE_ZONE_RADIUS + 50, Math.pow(rawDist, 1/3) * (BOUNDARY_RADIUS - 150));
                ast.position.set(dist * Math.sin(phi) * Math.cos(theta), dist * Math.sin(phi) * Math.sin(theta), dist * Math.cos(phi));
                scene.add(ast); obstacles.push(ast);
            }

            spawnEnemies(10);
            clock = new THREE.Clock();

            window.addEventListener('keydown', e => {
                if(e.code === 'Escape') togglePause();
                if(e.code === 'KeyW') input.w = true;
                if(e.code === 'KeyS') input.s = true;
                if(e.code === 'KeyA') input.a = true;
                if(e.code === 'KeyD') input.d = true;
                if(e.code === 'Space' && !isPaused && !player.userData.isTurning) fireLaser(player, 0xff0000, true);
                if(e.code === 'KeyF' && !isPaused && !player.userData.isTurning) fireTorpedo();
            });
            window.addEventListener('keyup', e => {
                if(e.code === 'KeyW') input.w = false;
                if(e.code === 'KeyS') input.s = false;
                if(e.code === 'KeyA') input.a = false;
                if(e.code === 'KeyD') input.d = false;
            });
            window.addEventListener('mousemove', e => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = (e.clientY / window.innerHeight) * 2 - 1;
            });

            window.togglePause = () => {
                isPaused = !isPaused;
                document.getElementById('pause-screen').classList.toggle('hidden', !isPaused);
            };
        }

        function spawnEnemies(count) {
            const geom = new THREE.SphereGeometry(1, 6, 6), wing = new THREE.BoxGeometry(0.1, 4, 3);
            for(let i=0; i<count; i++) {
                const en = new THREE.Group();
                const core = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({color: 0x333333}));
                const w1 = new THREE.Mesh(wing, new THREE.MeshPhongMaterial({color: 0x111111})); w1.position.x = 1.5;
                const w2 = w1.clone(); w2.position.x = -1.5;
                en.add(core, w1, w2);
                const dist = Math.random() * (BOUNDARY_RADIUS - 200);
                en.position.set(THREE.MathUtils.randFloatSpread(dist), THREE.MathUtils.randFloatSpread(dist), THREE.MathUtils.randFloatSpread(dist));
                scene.add(en); enemies.push({mesh: en, health: 1});
            }
        }

        function createExplosion(position, color, scale = 1.0) {
            const particleCount = 25 * scale;
            const geo = new THREE.BoxGeometry(0.3 * scale, 0.3 * scale, 0.3 * scale);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
            for (let i = 0; i < particleCount; i++) {
                const p = new THREE.Mesh(geo, mat.clone());
                p.position.copy(position);
                // Faster, wider spread for torpedoes
                const spread = 0.8 * scale;
                const velocity = new THREE.Vector3((Math.random()-0.5)*spread, (Math.random()-0.5)*spread, (Math.random()-0.5)*spread);
                scene.add(p);
                particles.push({ mesh: p, velocity: velocity, life: 1.0 + (Math.random() * 0.5) });
            }
        }

        function fireLaser(source, color, isPlayer) {
            if (isPlayer) {
                const wingTips = [];
                source.traverse((child) => { if (child.isMesh && child.geometry.type === 'CylinderGeometry' && Math.abs(child.position.x) > 1.5) wingTips.push(child); });
                if (wingTips.length > 0) {
                    wingTips.sort((a, b) => a.position.x - b.position.x);
                    const activeTip = wingTips[laserIndex % wingTips.length];
                    const laser = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 4), new THREE.MeshBasicMaterial({ color: color }));
                    const tipPos = new THREE.Vector3(); activeTip.getWorldPosition(tipPos);
                    laser.position.copy(tipPos); laser.quaternion.copy(source.quaternion);
                    scene.add(laser); bullets.push({ mesh: laser, life: 120, isPlayer: true });
                    laserIndex++;
                }
            } else {
                const laser = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 2), new THREE.MeshBasicMaterial({color: color}));
                laser.position.copy(source.position); laser.quaternion.copy(source.quaternion);
                scene.add(laser); bullets.push({mesh: laser, life: 120, isPlayer: false});
            }
        }

        function fireTorpedo() {
            const geo = new THREE.SphereGeometry(0.6, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const torp = new THREE.Mesh(geo, mat);
            torp.position.copy(player.position);
            torp.quaternion.copy(player.quaternion);
            scene.add(torp);
            torpedoes.push({ 
                mesh: torp, 
                dist: 0, 
                velocity: new THREE.Vector3(0, 0, -TORPEDO_SPEED).applyQuaternion(player.quaternion) 
            });
        }

        function createTorpedoTrail(pos) {
            const pGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const pMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true });
            const p = new THREE.Mesh(pGeo, pMat);
            p.position.copy(pos);
            scene.add(p);
            // Torpedo trail stays longer (0.8 vs original 0.5)
            particles.push({ mesh: p, velocity: new THREE.Vector3(0,0,0), life: 0.8 });
        }

        function animate() {
            requestAnimationFrame(animate);
            if(isPaused || !gameActive) return;

            const dt = clock.getDelta(), now = Date.now();
            const staminaFill = document.getElementById('stamina-fill');
            const staminaParent = document.getElementById('stamina-parent');

            const isBoosting = input.w && !isStaminaDepleted && stamina > 0;
            
            if (isBoosting) {
                stamina -= STAMINA_DRAIN * dt;
                lastBoostTime = now;
                if (stamina <= 0) {
                    stamina = 0; isStaminaDepleted = true;
                    staminaParent.classList.add('stamina-depleted');
                }
            } else {
                if (now - lastBoostTime > RECHARGE_DELAY) {
                    stamina += STAMINA_RECHARGE * dt;
                    if (stamina >= MAX_STAMINA) {
                        stamina = MAX_STAMINA; isStaminaDepleted = false;
                        staminaParent.classList.remove('stamina-depleted');
                    }
                }
            }
            staminaFill.style.width = `${stamina}%`;

            wingObjects.forEach((wing, i) => {
                const restAngle = (i === 0 || i === 3) ? 0.25 : -0.25;
                const targetAngle = isBoosting ? 0 : restAngle;
                wing.rotation.z = THREE.MathUtils.lerp(wing.rotation.z, targetAngle, 0.05);
            });

            engines.forEach(eng => {
                const engineColor = isStaminaDepleted ? 0xff0000 : 0x00ffff;
                eng.mesh.material.color.setHex(engineColor);
                eng.light.color.setHex(engineColor);
                eng.light.intensity = THREE.MathUtils.lerp(eng.light.intensity, speed * 2, 0.1);
                eng.mesh.scale.setScalar(THREE.MathUtils.lerp(eng.mesh.scale.x, 0.5 + speed * 0.5, 0.1));
            });

            let targetSpeed = isBoosting ? 2.5 : (input.s ? 0.2 : 0.8);
            speed = THREE.MathUtils.lerp(speed, targetSpeed, 0.05);
            camera.position.z = THREE.MathUtils.lerp(camera.position.z, 8 + (speed - 0.8) * 2.5, 0.05);
            camera.fov = THREE.MathUtils.lerp(camera.fov, 75 + (speed * 4), 0.05);
            camera.updateProjectionMatrix();

            const targetX = (window.innerWidth / 2) + (mouse.x * 30);
            const targetY = (window.innerHeight / 2) + (mouse.y * -30);
            reticlePos.x = THREE.MathUtils.lerp(reticlePos.x, targetX, 0.1);
            reticlePos.y = THREE.MathUtils.lerp(reticlePos.y, targetY, 0.1);
            const reticleEl = document.getElementById('reticle');
            reticleEl.style.left = `${reticlePos.x - 20}px`; reticleEl.style.top = `${reticlePos.y - 20}px`;

            if (!player.userData.isTurning) {
                player.rotateX(mouse.y * 0.04); player.rotateY(-mouse.x * 0.04);
                if(input.a) player.rotateZ(0.05); if(input.d) player.rotateZ(-0.05);
            }
            player.translateZ(-speed);

            const distFromCenter = player.position.length();
            if (distFromCenter > BOUNDARY_RADIUS && !player.userData.isTurning) {
                player.userData.isTurning = true; document.getElementById('warning').style.display = 'block';
            }
            if (player.userData.isTurning) {
                const dirToCenter = new THREE.Vector3(0,0,0).sub(player.position).normalize();
                player.quaternion.slerp(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), dirToCenter), 0.03);
                player.rotateZ(0.02);
                if (distFromCenter < BOUNDARY_RADIUS - 100) {
                    player.userData.isTurning = false; document.getElementById('warning').style.display = 'none';
                }
            }

            enemies.forEach(en => {
                const steer = new THREE.Vector3().subVectors(player.position, en.mesh.position).normalize();
                en.mesh.quaternion.slerp(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), steer), ENEMY_TURN_SPEED);
                en.mesh.translateZ(-ENEMY_MAX_SPEED);
                if(Math.random() < ENEMY_FIRE_RATE) fireLaser(en.mesh, 0x00ff00, false);
            });

            for(let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.mesh.translateZ(-BULLET_SPEED); b.life--;
                if(b.isPlayer) {
                    enemies.forEach((en, eIdx) => {
                        if(b.mesh.position.distanceTo(en.mesh.position) < 4) {
                            createExplosion(en.mesh.position, 0xffff00, 1.0);
                            scene.remove(en.mesh); enemies.splice(eIdx, 1); b.life = 0;
                        }
                    });
                } else if(b.mesh.position.distanceTo(player.position) < 4) {
                    shields -= 10; b.life = 0;
                    document.getElementById('damage-flash').style.opacity = "1"; 
                    setTimeout(() => { document.getElementById('damage-flash').style.opacity = "0"; }, 100);
                }
                if(b.life <= 0) { scene.remove(b.mesh); bullets.splice(i, 1); }
            }

            // --- Torpedo Animation & Radial Collision ---
            for(let i = torpedoes.length - 1; i >= 0; i--) {
                const t = torpedoes[i];
                t.mesh.position.add(t.velocity);
                t.dist += TORPEDO_SPEED;
                createTorpedoTrail(t.mesh.position);

                let impact = false;
                // Direct Hit Check
                enemies.forEach(en => { if(t.mesh.position.distanceTo(en.mesh.position) < 6) impact = true; });
                obstacles.forEach(ast => { if(t.mesh.position.distanceTo(ast.position) < (ast.geometry.parameters.radius * ast.scale.x + 1)) impact = true; });

                if(impact || t.dist > TORPEDO_RANGE) {
                    const blastPos = t.mesh.position.clone();
                    createExplosion(blastPos, 0x00ffff, 3.0); // Big 3x scale boom
                    
                    // Radial Damage: Check all enemies within blast radius
                    for (let eIdx = enemies.length - 1; eIdx >= 0; eIdx--) {
                        if (blastPos.distanceTo(enemies[eIdx].mesh.position) < TORPEDO_BLAST_RADIUS) {
                            createExplosion(enemies[eIdx].mesh.position, 0xffff00, 1.0);
                            scene.remove(enemies[eIdx].mesh);
                            enemies.splice(eIdx, 1);
                        }
                    }
                    
                    scene.remove(t.mesh);
                    torpedoes.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.velocity);
                p.life -= 0.015; // Slower fade for longer presence
                p.mesh.scale.setScalar(p.life);
                p.mesh.material.opacity = Math.min(p.life, 1.0);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            if(shields <= 0 && gameActive) { gameActive = false; document.getElementById('lose-screen').classList.remove('hidden'); }
            if(enemies.length === 0 && gameActive) { gameActive = false; document.getElementById('win-screen').classList.remove('hidden'); }

            document.getElementById('speed-val').innerText = Math.round(speed * 100);
            document.getElementById('shield-val').innerText = Math.max(0, Math.round(shields));
            document.getElementById('enemy-val').innerText = enemies.length;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>